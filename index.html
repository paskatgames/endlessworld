<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <title>Three.js RPG - Advanced</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px; left: 10px;
            color: white; font-family: sans-serif; font-weight: bold;
            background: rgba(0,0,0,0.6); padding: 15px;
            pointer-events: none; user-select: none;
            border-radius: 5px;
        }
        #blocker {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex; align-items: center; justify-content: center;
            color: white; font-family: sans-serif; font-size: 24px;
            cursor: pointer; z-index: 999;
        }
        #loading {
            position: absolute; bottom: 10px; right: 10px; color: yellow; font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="info">
        WASD = Liiku <br> SPACE = Hyppää <br> HIIRI = Käänny <br> LMB = Potkaise (Stop & Attack)
    </div>
    <div id="loading">Ladataan resursseja...</div>
    <div id="blocker">Klikkaa pelataksesi</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { createNoise2D } from 'simplex-noise';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- ASETUKSET ---
        const CONFIG = {
            CHUNK_SIZE: 60,
            DRAW_DISTANCE: 2,
            SPEED: 10,
            JUMP_FORCE: 20,
            GRAVITY: 40,
            // Hienosäädä tätä, jos jalat uppoavat edelleen tai hahmo leijuu
            PLAYER_HEIGHT_OFFSET: 1.5, 
            ENEMY_COUNT_PER_CHUNK: 1,
            // Listaa tähän tiedostot, joita sinulla on /mallit/ -kansiossa
            AVAILABLE_MODELS: ['tree.glb', 'rock.glb', 'flower.glb', 'bush.glb'] 
        };

        // --- GLOBAL VARIABLES ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, CONFIG.CHUNK_SIZE * (CONFIG.DRAW_DISTANCE - 0.5));

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Valot
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.5);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 60; dirLight.shadow.camera.bottom = -60;
        dirLight.shadow.camera.left = -60; dirLight.shadow.camera.right = 60;
        dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- SHADERIT (VESI) ---
        const waterVertexShader = `
            uniform float uTime;
            varying vec2 vUv;
            varying float vElevation;
            void main() {
                vUv = uv;
                vec3 pos = position;
                // Aallot
                float elevation = sin(pos.x * 2.0 + uTime) * 0.3;
                elevation += sin(pos.y * 1.5 + uTime * 0.5) * 0.3;
                pos.z += elevation; // Plane on käännetty, joten Z on "ylös" lokaalisti
                vElevation = elevation;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;
        const waterFragmentShader = `
            uniform float uTime;
            varying vec2 vUv;
            varying float vElevation;
            void main() {
                vec3 waterColor = vec3(0.0, 0.4, 0.8);
                vec3 foamColor = vec3(1.0, 1.0, 1.0);
                // Sekoita värejä korkeuden (aallonharjan) mukaan
                float mixStrength = smoothstep(0.1, 0.4, vElevation);
                vec3 color = mix(waterColor, foamColor, mixStrength);
                gl_FragColor = vec4(color, 0.85); // Hieman läpinäkyvä
            }
        `;
        const waterUniforms = { uTime: { value: 0 } };
        const waterMaterial = new THREE.ShaderMaterial({
            vertexShader: waterVertexShader,
            fragmentShader: waterFragmentShader,
            uniforms: waterUniforms,
            transparent: true,
            side: THREE.DoubleSide
        });

        // --- PLAYER SETUP ---
        const playerPivot = new THREE.Object3D();
        playerPivot.position.set(0, 10, 0);
        scene.add(playerPivot);

        const controls = new PointerLockControls(camera, document.body);
        const blocker = document.getElementById('blocker');
        blocker.addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => blocker.style.display = 'none');
        controls.addEventListener('unlock', () => blocker.style.display = 'flex');

        // Hahmon lataus
        const loader = new GLTFLoader();
        let mixer, playerMesh;
        let animationsMap = {};
        let currentAction = 'idle';
        let isAttacking = false;

        loader.load('./chars/testchard.glb', (gltf) => {
            playerMesh = gltf.scene;
            playerMesh.traverse(c => { if(c.isMesh) c.castShadow = true; });
            playerMesh.rotation.y = Math.PI; // Käännetään selkä kameraan
            playerMesh.position.y = -CONFIG.PLAYER_HEIGHT_OFFSET; // Lasketaan pivotin keskeltä jalkoihin
            playerPivot.add(playerMesh);

            mixer = new THREE.AnimationMixer(playerMesh);
            gltf.animations.forEach(clip => {
                animationsMap[clip.name.toLowerCase()] = mixer.clipAction(clip);
            });
            fadeToAction('idle', 0.2);
            document.getElementById('loading').style.display = 'none';
        }, undefined, (err) => {
            console.warn("Hahmoa ei löytynyt, käytetään laatikkoa.");
            const geo = new THREE.BoxGeometry(1, 2, 1);
            playerMesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color:'red'}));
            playerMesh.position.y = -1;
            playerPivot.add(playerMesh);
            document.getElementById('loading').style.display = 'none';
        });

        function fadeToAction(name, duration) {
            if(!animationsMap[name]) return;
            const prev = animationsMap[currentAction];
            const active = animationsMap[name];
            if(prev !== active) {
                if(prev) prev.fadeOut(duration);
                active.reset().fadeIn(duration).play();
                currentAction = name;
            }
        }

        // --- MAAILMAN GENERINTI ---
        const noise2D = createNoise2D();
        const chunks = new Map();
        const enemies = []; // Lista vihollisille

        function getTerrainHeight(x, z) {
            let y = noise2D(x * 0.01, z * 0.01) * 8; // Perusmuodot
            y += noise2D(x * 0.03, z * 0.03) * 3;    // Yksityiskohdat
            y += noise2D(x * 0.1, z * 0.1) * 0.5;    // Pieni karkeus
            
            // Tehdään tasankoja
            if (y < -2) y = -2.5; // Vedenpohja
            return y;
        }

        // --- OBJEKTIEN LATAUS (PROPS) ---
        function spawnProp(x, y, z, parentGroup) {
            // Arvotaan malli listasta
            const randomModelName = CONFIG.AVAILABLE_MODELS[Math.floor(Math.random() * CONFIG.AVAILABLE_MODELS.length)];
            const path = `./mallit/${randomModelName}`;

            loader.load(path, (gltf) => {
                const model = gltf.scene;
                model.position.set(x, y, z);
                
                // Satunnainen skaalaus ja kääntö
                const scale = 0.8 + Math.random() * 0.6;
                model.scale.set(scale, scale, scale);
                model.rotation.y = Math.random() * Math.PI * 2;
                
                model.traverse(c => { 
                    if(c.isMesh) {
                        c.castShadow = true; 
                        c.receiveShadow = true;
                    } 
                });
                parentGroup.add(model);
            }, undefined, (err) => {
                // Fallback: Vihreä kuutio jos mallia ei ole
                const geo = new THREE.BoxGeometry(1, 1, 1);
                const mat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y + 0.5, z);
                mesh.castShadow = true;
                parentGroup.add(mesh);
            });
        }

        // --- VIHOLLISET ---
        function spawnEnemy(x, y, z) {
            const enemyGroup = new THREE.Group();
            enemyGroup.position.set(x, y, z);
            
            // Data vihollisen logiikalle
            enemyGroup.userData = { 
                hp: 100, 
                state: 'idle', 
                velocity: new THREE.Vector3(),
                mixer: null,
                actions: {}
            };

            loader.load('./enemies/enemy1.glb', (gltf) => {
                const model = gltf.scene;
                model.scale.set(1,1,1); // Säädä tarvittaessa
                model.traverse(c => { if(c.isMesh) c.castShadow = true; });
                enemyGroup.add(model);

                // Animaatiot
                const mix = new THREE.AnimationMixer(model);
                enemyGroup.userData.mixer = mix;
                gltf.animations.forEach(clip => {
                    enemyGroup.userData.actions[clip.name.toLowerCase()] = mix.clipAction(clip);
                });
                // Käynnistä idle jos löytyy, muuten ei mitään
                if(enemyGroup.userData.actions['idle']) enemyGroup.userData.actions['idle'].play();

            }, undefined, (err) => {
                // Fallback: Musta kuutio
                const geo = new THREE.BoxGeometry(1, 2, 1);
                const mat = new THREE.MeshStandardMaterial({ color: 0x000000 }); // Musta
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.y = 1;
                enemyGroup.add(mesh);
            });

            scene.add(enemyGroup);
            enemies.push(enemyGroup);
        }

        function updateEnemies(delta, playerPos) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = enemy.position.distanceTo(playerPos);
                
                // Yksinkertainen AI: Seuraa jos lähellä
                if (dist < 20 && dist > 1.5) {
                    const dir = new THREE.Vector3().subVectors(playerPos, enemy.position).normalize();
                    enemy.position.addScaledVector(dir, 4 * delta); // Nopeus 4
                    enemy.lookAt(playerPos.x, enemy.position.y, playerPos.z);
                    
                    // Vaihda animaatio runiin jos on
                    if(enemy.userData.actions['run'] && enemy.userData.state !== 'run') {
                        if(enemy.userData.actions['idle']) enemy.userData.actions['idle'].stop();
                        enemy.userData.actions['run'].play();
                        enemy.userData.state = 'run';
                    }
                } else {
                    // Pysähdy
                    if(enemy.userData.actions['idle'] && enemy.userData.state !== 'idle') {
                        if(enemy.userData.actions['run']) enemy.userData.actions['run'].stop();
                        enemy.userData.actions['idle'].play();
                        enemy.userData.state = 'idle';
                    }
                }

                // Painovoima ja maanpinta viholliselle
                const groundY = getTerrainHeight(enemy.position.x, enemy.position.z);
                if (enemy.position.y > groundY) {
                    enemy.position.y -= CONFIG.GRAVITY * delta;
                }
                if (enemy.position.y < groundY) {
                    enemy.position.y = groundY;
                }

                // Päivitä animaatiomikseri
                if(enemy.userData.mixer) enemy.userData.mixer.update(delta);
            }
        }

        function createChunk(chunkX, chunkZ) {
            const group = new THREE.Group();
            
            // --- MAASTO (Vertex Colors) ---
            // Käytämme Vertex Colors -ominaisuutta tehdäksemme "paremman grass shaderin" ilman raskasta koodia
            const geometry = new THREE.PlaneGeometry(CONFIG.CHUNK_SIZE, CONFIG.CHUNK_SIZE, 30, 30);
            geometry.rotateX(-Math.PI / 2);

            const count = geometry.attributes.position.count;
            geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(count * 3), 3));

            const positions = geometry.attributes.position;
            const colors = geometry.attributes.color;
            const vertex = new THREE.Vector3();
            const color = new THREE.Color();

            // Väripaletit
            const cSand = new THREE.Color(0xe6c288);
            const cGrass = new THREE.Color(0x567d46); // Tummempi vihreä
            const cRock = new THREE.Color(0x666666);
            const cSnow = new THREE.Color(0xffffff);

            for (let i = 0; i < count; i++) {
                vertex.fromBufferAttribute(positions, i);
                const worldX = vertex.x + (chunkX * CONFIG.CHUNK_SIZE);
                const worldZ = vertex.z + (chunkZ * CONFIG.CHUNK_SIZE);
                const h = getTerrainHeight(worldX, worldZ);
                
                positions.setY(i, h);

                // Väritetään korkeuden mukaan
                if (h < -1.5) color.copy(cSand);           // Hiekka
                else if (h < 5) color.copy(cGrass);        // Ruoho
                else if (h < 10) color.copy(cRock);        // Kivi
                else color.copy(cSnow);                    // Lumi

                // Lisätään pientä satunnaisvaihtelua väriin
                color.offsetHSL(0, 0, (Math.random() - 0.5) * 0.05);
                
                colors.setXYZ(i, color.r, color.g, color.b);
            }
            
            geometry.computeVertexNormals();

            const mat = new THREE.MeshStandardMaterial({ 
                vertexColors: true, // TÄRKEÄ: Sallii värit
                roughness: 0.8,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(geometry, mat);
            ground.receiveShadow = true;
            ground.castShadow = true;
            group.add(ground);

            // --- VESI ---
            const waterGeo = new THREE.PlaneGeometry(CONFIG.CHUNK_SIZE, CONFIG.CHUNK_SIZE, 10, 10);
            waterGeo.rotateX(-Math.PI / 2);
            const water = new THREE.Mesh(waterGeo, waterMaterial);
            water.position.y = -2.0; 
            group.add(water);

            // --- PROPS & VIHOLLISET ---
            for(let i=0; i<8; i++) {
                const rX = (Math.random() - 0.5) * CONFIG.CHUNK_SIZE;
                const rZ = (Math.random() - 0.5) * CONFIG.CHUNK_SIZE;
                const wX = rX + chunkX * CONFIG.CHUNK_SIZE;
                const wZ = rZ + chunkZ * CONFIG.CHUNK_SIZE;
                const y = getTerrainHeight(wX, wZ);

                // Ei vedessä
                if(y > -1.0) {
                    spawnProp(wX, y, wZ, group);
                }
            }
            
            // Spawn Enemy (satunnaisesti)
            if (Math.random() > 0.5) {
                const rX = (Math.random() - 0.5) * CONFIG.CHUNK_SIZE;
                const rZ = (Math.random() - 0.5) * CONFIG.CHUNK_SIZE;
                const wX = rX + chunkX * CONFIG.CHUNK_SIZE;
                const wZ = rZ + chunkZ * CONFIG.CHUNK_SIZE;
                const y = getTerrainHeight(wX, wZ);
                if(y > -1.0) spawnEnemy(wX, y, wZ);
            }

            group.position.set(chunkX * CONFIG.CHUNK_SIZE, 0, chunkZ * CONFIG.CHUNK_SIZE);
            scene.add(group);
            return group;
        }

        // --- GAME LOOP ---
        const keys = { w: false, a: false, s: false, d: false, space: false };
        window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        window.addEventListener('keydown', (e) => { if(e.code === 'Space') keys.space = true; });
        window.addEventListener('keyup', (e) => { if(e.code === 'Space') keys.space = false; });

        // HYÖKKÄYS
        window.addEventListener('mousedown', (e) => {
            if(controls.isLocked && !isAttacking && e.button === 0) {
                performAttack();
            }
        });

        function performAttack() {
            if(!animationsMap['kick']) return;
            isAttacking = true;
            
            // Pysäytä liike välittömästi
            playerVelocity.set(0, playerVelocity.y, 0);

            const action = animationsMap['kick'];
            action.reset();
            action.setLoop(THREE.LoopOnce);
            action.clampWhenFinished = true;
            fadeToAction('kick', 0.1);

            mixer.addEventListener('finished', onAttackFinished);
        }

        function onAttackFinished(e) {
            if (e.action === animationsMap['kick']) {
                isAttacking = false;
                mixer.removeEventListener('finished', onAttackFinished);
                const isMoving = keys.w || keys.s || keys.a || keys.d;
                fadeToAction(isMoving ? 'run' : 'idle', 0.2);
            }
        }

        const playerVelocity = new THREE.Vector3();
        const clock = new THREE.Clock();
        let isGrounded = false;

        function updateChunks() {
            const pX = Math.round(playerPivot.position.x / CONFIG.CHUNK_SIZE);
            const pZ = Math.round(playerPivot.position.z / CONFIG.CHUNK_SIZE);
            const active = new Set();
            for(let x=-CONFIG.DRAW_DISTANCE; x<=CONFIG.DRAW_DISTANCE; x++){
                for(let z=-CONFIG.DRAW_DISTANCE; z<=CONFIG.DRAW_DISTANCE; z++){
                    const k = `${pX+x},${pZ+z}`;
                    active.add(k);
                    if(!chunks.has(k)) chunks.set(k, createChunk(pX+x, pZ+z));
                }
            }
            for(const [k, obj] of chunks) {
                if(!active.has(k)) {
                    scene.remove(obj);
                    // Puhdistus (tärkeää!)
                    obj.traverse(c => { if(c.geometry) c.geometry.dispose(); });
                    chunks.delete(k);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            
            // Päivitä shaderien aika (aallot)
            waterUniforms.uTime.value = clock.getElapsedTime();

            if (controls.isLocked) {
                // --- LIIKKEEN LOGIIKKA ---
                
                // Jos hyökkää, ei voi liikkua (mutta voi kääntyä)
                if (!isAttacking) {
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    forward.y = 0; forward.normalize();
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    right.y = 0; right.normalize();

                    const moveDir = new THREE.Vector3();
                    if (keys.w) moveDir.add(forward);
                    if (keys.s) moveDir.sub(forward);
                    if (keys.d) moveDir.add(right);
                    if (keys.a) moveDir.sub(right);

                    if (moveDir.length() > 0) {
                        moveDir.normalize();
                        playerVelocity.x = moveDir.x * CONFIG.SPEED;
                        playerVelocity.z = moveDir.z * CONFIG.SPEED;
                        
                        // Käännä hahmo (mesh)
                        const angle = Math.atan2(moveDir.x, moveDir.z);
                        playerPivot.rotation.y = angle + Math.PI; 
                        
                        if(isGrounded) fadeToAction('run', 0.2);
                    } else {
                        playerVelocity.x = 0;
                        playerVelocity.z = 0;
                        if(isGrounded) fadeToAction('idle', 0.2);
                    }

                    if (keys.space && isGrounded) {
                        playerVelocity.y = CONFIG.JUMP_FORCE;
                        isGrounded = false;
                        fadeToAction('jump', 0.1);
                    }
                } else {
                    // Hyökkäyksen aikana nollataan nopeus
                    playerVelocity.x = 0;
                    playerVelocity.z = 0;
                }
                
                // Painovoima
                playerVelocity.y -= CONFIG.GRAVITY * delta;
                playerPivot.position.addScaledVector(playerVelocity, delta);

                // --- CLIPPING FIX (MAA) ---
                const terrainH = getTerrainHeight(playerPivot.position.x, playerPivot.position.z);
                
                // Tarkistus: Jos jalkojen taso (pivot.y) menisi maan alle
                if (playerPivot.position.y < terrainH) {
                    playerPivot.position.y = terrainH;
                    playerVelocity.y = 0;
                    isGrounded = true;
                }

                // Kamera
                camera.position.copy(playerPivot.position);
                camera.position.y += 3; // Kameran korkeus
                const camOffset = new THREE.Vector3(0, 0, 5).applyQuaternion(camera.quaternion);
                camera.position.add(camOffset);

                // Kameran törmäys maahan
                const camH = getTerrainHeight(camera.position.x, camera.position.z);
                if(camera.position.y < camH + 0.5) camera.position.y = camH + 0.5;

                // Päivitä viholliset
                updateEnemies(delta, playerPivot.position);
            }

            if(mixer) mixer.update(delta);
            updateChunks();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>

