<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <title>Three.js RPG - Battle & Raycast</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #ui {
            position: absolute; top: 10px; left: 10px;
            color: white; font-family: sans-serif; pointer-events: none;
        }
        .bar-container {
            width: 200px; height: 20px; background: rgba(0,0,0,0.5);
            border: 2px solid #fff; border-radius: 10px; overflow: hidden;
        }
        #hp-bar {
            width: 100%; height: 100%; background: #ff3333;
            transition: width 0.2s ease-out;
        }
        #blocker {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: flex; align-items: center;
            justify-content: center; color: white; font-family: sans-serif;
            font-size: 24px; cursor: pointer; z-index: 999;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div style="margin-bottom: 5px;">PLAYER HEALTH</div>
        <div class="bar-container"><div id="hp-bar"></div></div>
    </div>
    <div id="blocker">KLIKKAA PELATAKSESI</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { createNoise2D } from 'simplex-noise';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- ASETUKSET ---
        const CONFIG = {
            CHUNK_SIZE: 60,
            DRAW_DISTANCE: 2,
            PLAYER_MAX_HP: 100,
            AVAILABLE_MODELS: ['tree.glb', 'rock.glb', 'bush.glb']
        };

        let playerHP = CONFIG.PLAYER_MAX_HP;
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1.2);
        light.position.set(50, 100, 50);
        light.castShadow = true;
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));

        // --- PELAAJA & KONTROLLIT ---
        const playerPivot = new THREE.Group();
        scene.add(playerPivot);
        const controls = new PointerLockControls(camera, document.body);
        document.getElementById('blocker').addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => document.getElementById('blocker').style.display = 'none');
        controls.addEventListener('unlock', () => document.getElementById('blocker').style.display = 'flex');

        const loader = new GLTFLoader();
        let mixer, playerMesh, isAttacking = false, animations = {};
        
        loader.load('./chars/testchard.glb', (gltf) => {
            playerMesh = gltf.scene;
            playerMesh.rotation.y = Math.PI;
            playerMesh.position.y = -1.1;
            playerPivot.add(playerMesh);
            mixer = new THREE.AnimationMixer(playerMesh);
            gltf.animations.forEach(a => animations[a.name.toLowerCase()] = mixer.clipAction(a));
            animations['idle']?.play();
        });

        // --- MAAILMA ---
        const noise2D = createNoise2D();
        const chunks = new Map();
        const enemies = [];
        const particles = [];

        function getHeight(x, z) {
            return noise2D(x * 0.02, z * 0.02) * 6 + noise2D(x * 0.05, z * 0.05) * 2;
        }

        // Raycaster-sijoittelu propseille
        function spawnPropWithRaycast(localX, localZ, group, groundMesh) {
            const ray = new THREE.Raycaster(new THREE.Vector3(localX, 50, localZ), new THREE.Vector3(0, -1, 0));
            const intersect = ray.intersectObject(groundMesh);
            
            if (intersect.length > 0) {
                const y = intersect[0].point.y;
                if (y < -1.5) return;

                const name = CONFIG.AVAILABLE_MODELS[Math.floor(Math.random() * CONFIG.AVAILABLE_MODELS.length)];
                loader.load(`./mallit/${name}`, (gltf) => {
                    const m = gltf.scene;
                    m.position.set(localX, y, localZ);
                    m.rotation.y = Math.random() * Math.PI;
                    m.scale.setScalar(0.8 + Math.random() * 0.5);
                    group.add(m);
                }, undefined, () => {
                    const box = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({color: 0x228b22}));
                    box.position.set(localX, y + 1, localZ);
                    group.add(box);
                });
            }
        }

        function createExplosion(pos) {
            for(let i=0; i<15; i++) {
                const size = 0.2 + Math.random() * 0.3;
                const p = new THREE.Mesh(
                    new THREE.BoxGeometry(size, size, size),
                    new THREE.MeshStandardMaterial({color: 0x333333})
                );
                p.position.copy(pos);
                p.userData.vel = new THREE.Vector3(
                    (Math.random()-0.5)*10, Math.random()*10, (Math.random()-0.5)*10
                );
                p.userData.life = 1.0;
                scene.add(p);
                particles.push(p);
            }
        }

        function spawnEnemy(x, z) {
            const group = new THREE.Group();
            group.position.set(x, 20, z);
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2, 1.2), new THREE.MeshStandardMaterial({color: 0x111111}));
            group.add(mesh);
            scene.add(group);
            enemies.push(group);
        }

        function createChunk(cX, cZ) {
            const group = new THREE.Group();
            const geo = new THREE.PlaneGeometry(60, 60, 20, 20);
            geo.rotateX(-Math.PI/2);
            const pos = geo.attributes.position;
            for(let i=0; i<pos.count; i++) {
                pos.setY(i, getHeight(pos.getX(i) + cX*60, pos.getZ(i) + cZ*60));
            }
            geo.computeVertexNormals();
            const ground = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color: 0x557744}));
            ground.receiveShadow = true;
            group.add(ground);

            for(let i=0; i<6; i++) {
                spawnPropWithRaycast((Math.random()-0.5)*50, (Math.random()-0.5)*50, group, ground);
            }
            if(Math.random() > 0.6) spawnEnemy(cX*60 + (Math.random()-0.5)*40, cZ*60 + (Math.random()-0.5)*40);

            group.position.set(cX*60, 0, cZ*60);
            scene.add(group);
            chunks.set(`${cX},${cZ}`, group);
        }

        // --- TAISTELU JA LIIKE ---
        const keys = {}, vel = new THREE.Vector3();
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        window.addEventListener('mousedown', e => {
            if(controls.isLocked && !isAttacking && e.button === 0) {
                isAttacking = true;
                const kick = animations['kick'];
                if(kick) {
                    kick.reset().setLoop(THREE.LoopOnce).play();
                    // Osuman tarkistus
                    setTimeout(() => checkHit(), 300); 
                    mixer.addEventListener('finished', () => isAttacking = false, {once: true});
                } else {
                    setTimeout(() => { isAttacking = false; checkHit(); }, 500);
                }
            }
        });

        function checkHit() {
            const hitDist = 2.5;
            // Pelaajan rintamasuunta
            const forward = new THREE.Vector3(0,0,1).applyQuaternion(playerPivot.quaternion);
            
            for(let i=enemies.length-1; i>=0; i--) {
                const en = enemies[i];
                const toEnemy = new THREE.Vector3().subVectors(en.position, playerPivot.position);
                const dist = toEnemy.length();
                
                // Tarkistetaan etäisyys ja onko vihollinen pelaajan edessä (pistetulo)
                if(dist < hitDist) {
                    createExplosion(en.position.clone());
                    scene.remove(en);
                    enemies.splice(i, 1);
                }
            }
        }

        const clock = new THREE.Clock();
        let attackTimer = 0;

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);

            if(controls.isLocked) {
                if(!isAttacking) {
                    const camF = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); camF.y = 0; camF.normalize();
                    const camR = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); camR.y = 0; camR.normalize();
                    const move = new THREE.Vector3();
                    if(keys['KeyW']) move.add(camF); if(keys['KeyS']) move.sub(camF);
                    if(keys['KeyD']) move.add(camR); if(keys['KeyA']) move.sub(camR);

                    if(move.length() > 0) {
                        move.normalize();
                        vel.x = move.x * 12; vel.z = move.z * 12;
                        playerPivot.rotation.y = Math.atan2(move.x, move.z) + Math.PI;
                        if(animations['run'] && !animations['run'].isRunning()) animations['run'].play();
                    } else {
                        vel.x *= 0.1; vel.z *= 0.1;
                        animations['run']?.stop();
                    }
                } else {
                    vel.x = 0; vel.z = 0;
                }

                vel.y -= 40 * dt;
                playerPivot.position.addScaledVector(vel, dt);
                const groundH = getHeight(playerPivot.position.x, playerPivot.position.z);
                if(playerPivot.position.y < groundH) { playerPivot.position.y = groundH; vel.y = 0; }

                camera.position.copy(playerPivot.position);
                camera.position.y += 4;
                camera.position.add(new THREE.Vector3(0,0,7).applyQuaternion(camera.quaternion));
            }

            // Vihollisten AI ja hyökkäys
            attackTimer += dt;
            enemies.forEach(en => {
                const d = en.position.distanceTo(playerPivot.position);
                if(d < 15 && d > 1.2) {
                    en.position.addScaledVector(new THREE.Vector3().subVectors(playerPivot.position, en.position).normalize(), 5 * dt);
                    en.lookAt(playerPivot.position.x, en.position.y, playerPivot.position.z);
                }
                // Vihollinen lyö
                if(d < 1.8 && attackTimer > 1.0) {
                    playerHP -= 10;
                    attackTimer = 0;
                    document.getElementById('hp-bar').style.width = playerHP + "%";
                    if(playerHP <= 0) alert("KUOLIT!");
                }
                en.position.y = getHeight(en.position.x, en.position.z);
            });

            // Räjähdyspartikkelit
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.userData.vel.y -= 20 * dt;
                p.position.addScaledVector(p.userData.vel, dt);
                p.userData.life -= dt;
                if(p.userData.life <= 0) { scene.remove(p); particles.splice(i, 1); }
            }

            if(mixer) mixer.update(dt);
            const cX = Math.round(playerPivot.position.x/60), cZ = Math.round(playerPivot.position.z/60);
            for(let x=-1; x<=1; x++) for(let z=-1; z<=1; z++) {
                if(!chunks.has(`${cX+x},${cZ+z}`)) createChunk(cX+x, cZ+z);
            }

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
