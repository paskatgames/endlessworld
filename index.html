<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <title>Three.js RPG - Shaders & Models</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #ui {
            position: absolute; top: 15px; left: 15px; color: white; pointer-events: none;
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 12px; border: 1px solid #444;
        }
        .bar-container { width: 220px; height: 16px; background: #222; border: 1px solid #777; margin: 6px 0; border-radius: 8px; overflow: hidden; }
        #hp-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #ff4444, #aa0000); transition: 0.3s; }
        #xp-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #44ccff, #0066ff); transition: 0.3s; }
        #blocker {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; align-items: center;
            justify-content: center; color: white; font-size: 24px; cursor: pointer; z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="ui">
        <b>LEVEL <span id="lvl-txt">1</span></b>
        <div class="bar-container"><div id="hp-bar"></div></div>
        <div class="bar-container"><div id="xp-bar"></div></div>
        <div id="stats" style="font-size: 12px; color: #0f0;">Stats: Loading...</div>
    </div>
    <div id="blocker">KLIKKAA ALOITTAAKSESI</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { createNoise2D } from 'simplex-noise';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- MÄÄRITYKSET ---
        const CONFIG = {
            CHUNK_SIZE: 60,
            WATER_LEVEL: -2.5,
            PROP_FILES: ['tree.glb', 'rock.glb', 'flower.glb', 'bush.glb'], // Lisää tiedostonimet tänne
            ENEMY_MODEL: './enemies/enemy1.glb'
        };

        const PLAYER = { hp: 100, maxHp: 100, level: 1, xp: 0, nextLvl: 100, baseDmg: 40, speed: 14, jump: 23 };

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new PointerLockControls(camera, document.body);
        document.getElementById('blocker').addEventListener('click', () => controls.lock());

        const loader = new GLTFLoader();
        const noise2D = createNoise2D();
        const chunks = new Map();
        const enemies = [], potions = [], loadedProps = [];
        let enemyBaseMesh = null;

        // --- VALAISTUS JA TAIVAS ---
        const sun = new THREE.DirectionalLight(0xffffff, 1.5);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        scene.add(sun);
        scene.add(new THREE.AmbientLight(0x404040, 0.6));

        // --- MATERIAALIT (SHADERS) ---
        const waterMaterial = new THREE.MeshStandardMaterial({
            color: 0x0077ff,
            transparent: true,
            opacity: 0.8,
            roughness: 0.1,
        });

        // Lisätään aallot shader-muokkauksella
        waterMaterial.onBeforeCompile = (shader) => {
            shader.uniforms.time = { value: 0 };
            shader.vertexShader = `
                uniform float time;
                ${shader.vertexShader}
            `.replace(
                `#include <begin_vertex>`,
                `
                vec3 transformed = vec3(position);
                transformed.y += sin(transformed.x * 0.5 + time) * 0.2 + cos(transformed.z * 0.5 + time) * 0.2;
                `
            );
            waterMaterial.userData.shader = shader;
        };

        // --- MALLIEN LATAUS ---
        // Ladataan vihollinen
        loader.load(CONFIG.ENEMY_MODEL, 
            (gltf) => { enemyBaseMesh = gltf; },
            undefined, 
            () => { console.warn("Enemy model not found, using fallback."); }
        );

        // Ladataan propsit
        CONFIG.PROP_FILES.forEach(file => {
            loader.load(`./mallit/${file}`, (gltf) => {
                loadedProps.push(gltf.scene);
            });
        });

        // --- MAASTON GENERUUS ---
        function getHeight(x, z) {
            return noise2D(x * 0.015, z * 0.015) * 12 + noise2D(x * 0.05, z * 0.05) * 2;
        }

        function createChunk(cX, cZ) {
            const group = new THREE.Group();
            const geo = new THREE.PlaneGeometry(60, 60, 64, 64);
            geo.rotateX(-Math.PI / 2);

            const pos = geo.attributes.position;
            const colors = new Float32Array(pos.count * 3);
            for (let i = 0; i < pos.count; i++) {
                const px = pos.getX(i) + cX * 60, pz = pos.getZ(i) + cZ * 60;
                const h = getHeight(px, pz);
                pos.setY(i, h);

                let col = new THREE.Color();
                if (h < -1.8) col.set(0xd2b48c); // Hiekka
                else if (h < 6) col.set(0x3a6629); // Ruoho
                else if (h < 10) col.set(0x666666); // Kivi
                else col.set(0xffffff); // Lumi
                col.toArray(colors, i * 3);
            }
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geo.computeVertexNormals();

            const ground = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8 }));
            ground.receiveShadow = true;
            ground.name = "ground";
            group.add(ground);

            const water = new THREE.Mesh(new THREE.PlaneGeometry(60, 60, 32, 32), waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = CONFIG.WATER_LEVEL;
            group.add(water);

            // Propsi-spawnaus
            const ray = new THREE.Raycaster();
            for (let i = 0; i < 12; i++) {
                const rx = (Math.random() - 0.5) * 55, rz = (Math.random() - 0.5) * 55;
                ray.set(new THREE.Vector3(rx + cX * 60, 50, rz + cZ * 60), new THREE.Vector3(0, -1, 0));
                const hits = ray.intersectObject(ground);
                if (hits.length > 0 && hits[0].point.y > -1.5) {
                    if (loadedProps.length > 0) {
                        const prop = loadedProps[Math.floor(Math.random() * loadedProps.length)].clone();
                        prop.position.set(rx + cX * 60, hits[0].point.y, rz + cZ * 60);
                        scene.add(prop);
                    } else {
                        // Fallback: Vihreä kuutio
                        const cube = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({ color: 0x00ff00 }));
                        cube.position.set(rx + cX * 60, hits[0].point.y + 1, rz + cZ * 60);
                        scene.add(cube);
                    }
                }
            }

            if (Math.random() > 0.6) spawnEnemy(cX * 60 + (Math.random() - 0.5) * 40, cZ * 60 + (Math.random() - 0.5) * 40);

            group.position.set(cX * 60, 0, cZ * 60);
            scene.add(group);
            chunks.set(`${cX},${cZ}`, group);
        }

        // --- VIHANSIA (ENEMIES) ---
        function spawnEnemy(x, z) {
            const group = new THREE.Group();
            group.position.set(x, 15, z);
            
            let model, mixer, enemyAnims = {};
            
            if (enemyBaseMesh) {
                model = THREE.SkeletonUtils.clone(enemyBaseMesh.scene);
                mixer = new THREE.AnimationMixer(model);
                enemyBaseMesh.animations.forEach(clip => {
                    enemyAnims[clip.name.toLowerCase()] = mixer.clipAction(clip);
                });
                enemyAnims['idle']?.play();
            } else {
                // Fallback: Musta kuutio
                model = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshStandardMaterial({ color: 0x000000 }));
            }

            group.add(model);
            group.userData = { 
                hp: 100, maxHp: 100, 
                mixer: mixer, anims: enemyAnims, 
                state: 'idle', lastAttack: 0 
            };

            const hpF = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.15), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
            hpF.position.y = 3; group.userData.hpFill = hpF; group.add(hpF);

            scene.add(group);
            enemies.push(group);
        }

        // --- PELAAJAN SETUP JA LIIKE ---
        let playerMixer, playerAnims = {};
        const playerPivot = new THREE.Group();
        scene.add(playerPivot);

        loader.load('./chars/testchard.glb', (gltf) => {
            const model = gltf.scene;
            model.rotation.y = Math.PI;
            model.position.y = -1.1;
            playerPivot.add(model);
            playerMixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach(a => playerAnims[a.name.toLowerCase()] = playerMixer.clipAction(a));
            playerAnims['idle']?.play();
        });

        const keys = {}, vel = new THREE.Vector3();
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);
            const time = performance.now() * 0.001;

            if (waterMaterial.userData.shader) waterMaterial.userData.shader.uniforms.time.value = time;

            if (controls.isLocked) {
                const camF = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion); camF.y = 0; camF.normalize();
                const camR = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion); camR.y = 0; camR.normalize();
                const move = new THREE.Vector3();

                if (!playerAnims['kick']?.isRunning()) {
                    if (keys['KeyW']) move.add(camF); if (keys['KeyS']) move.sub(camF);
                    if (keys['KeyD']) move.add(camR); if (keys['KeyA']) move.sub(camR);

                    if (move.length() > 0) {
                        move.normalize();
                        vel.x = move.x * PLAYER.speed; vel.z = move.z * PLAYER.speed;
                        playerPivot.rotation.y = Math.atan2(move.x, move.z) + Math.PI;
                        playerAnims['run']?.play();
                    } else {
                        vel.x *= 0.1; vel.z *= 0.1;
                        playerAnims['run']?.stop();
                    }
                }

                vel.y -= 50 * dt;
                playerPivot.position.addScaledVector(vel, dt);
                const gh = getHeight(playerPivot.position.x, playerPivot.position.z);
                if (playerPivot.position.y < gh + 1.1) { playerPivot.position.y = gh + 1.1; vel.y = 0; }

                camera.position.copy(playerPivot.position).add(new THREE.Vector3(0, 5, 10).applyQuaternion(camera.quaternion));
            }

            // Vihollisten tekoäly ja animaatiot
            enemies.forEach((en, i) => {
                if (en.userData.mixer) en.userData.mixer.update(dt);
                const dist = en.position.distanceTo(playerPivot.position);
                
                if (dist < 15 && dist > 2) {
                    en.position.addScaledVector(new THREE.Vector3().subVectors(playerPivot.position, en.position).normalize(), 5 * dt);
                    en.lookAt(playerPivot.position.x, en.position.y, playerPivot.position.z);
                    if (en.userData.state !== 'run') {
                        en.userData.anims['idle']?.stop();
                        en.userData.anims['run']?.play();
                        en.userData.state = 'run';
                    }
                } else if (dist <= 2) {
                    if (performance.now() - en.userData.lastAttack > 1500) {
                        en.userData.anims['attack']?.reset().play();
                        PLAYER.hp -= 10;
                        en.userData.lastAttack = performance.now();
                        document.getElementById('hp-bar').style.width = (PLAYER.hp/PLAYER.maxHp)*100 + "%";
                    }
                }
                en.position.y = getHeight(en.position.x, en.position.z) + 1;
                en.userData.hpFill.lookAt(camera.position);
            });

            // Chunkien hallinta
            const pCX = Math.round(playerPivot.position.x / 60), pCZ = Math.round(playerPivot.position.z / 60);
            for (let x = -1; x <= 1; x++) for (let z = -1; z <= 1; z++) if (!chunks.has(`${pCX + x},${pCZ + z}`)) createChunk(pCX + x, pCZ + z);

            if (playerMixer) playerMixer.update(dt);
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
