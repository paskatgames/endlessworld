<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <title>Three.js RPG - Fixed Camera & Chunks</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #ui {
            position: absolute; top: 15px; left: 15px; color: white; pointer-events: none;
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 12px; border: 1px solid #444;
        }
        .bar-container { width: 220px; height: 14px; background: #222; border: 1px solid #666; margin: 6px 0; border-radius: 7px; overflow: hidden; }
        #hp-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #ff4444, #aa0000); transition: 0.3s; }
        #xp-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #44ccff, #0066ff); transition: 0.3s; }
        #stats { font-size: 13px; color: #00ffcc; font-weight: bold; }
        #blocker {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; align-items: center;
            justify-content: center; color: white; font-size: 26px; cursor: pointer; z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="ui">
        <b style="font-size: 18px;">LEVEL <span id="lvl-txt">1</span></b>
        <div style="margin-top:10px;">HP</div><div class="bar-container"><div id="hp-bar"></div></div>
        <div>XP</div><div class="bar-container"><div id="xp-bar"></div></div>
        <div id="stats">Päivitetään...</div>
    </div>
    <div id="blocker">KLIKKAA PELATAKSESI</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { createNoise2D } from 'simplex-noise';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- KONFIGURAATIO & STATS ---
        const CONFIG = {
            CHUNK_SIZE: 60,
            DRAW_DISTANCE: 2, // Lataa 2 chunkia joka suuntaan (5x5 grid)
            PLAYER_MAX_HP: 100
        };

        const PLAYER = {
            hp: 100, maxHp: 100,
            level: 1, xp: 0, nextLvl: 100,
            baseDmg: 30, speed: 14, jump: 20
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 140);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new PointerLockControls(camera, document.body);
        document.getElementById('blocker').addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => document.getElementById('blocker').style.display = 'none');
        controls.addEventListener('unlock', () => document.getElementById('blocker').style.display = 'flex');

        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(50, 100, 50);
        light.castShadow = true;
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));

        const loader = new GLTFLoader();
        let mixer, playerMesh, isAttacking = false, isGrounded = false, animations = {};
        const playerPivot = new THREE.Group();
        playerPivot.position.y = 10;
        scene.add(playerPivot);

        // --- MAASTO ---
        const noise2D = createNoise2D();
        const chunks = new Map();
        const enemies = [], particles = [];

        function getHeight(x, z) {
            let y = noise2D(x * 0.012, z * 0.012) * 12;
            y += noise2D(x * 0.06, z * 0.06) * 2;
            return y < -2 ? -3 : y; // Vesi-taso
        }

        function createChunk(cX, cZ) {
            const group = new THREE.Group();
            const geo = new THREE.PlaneGeometry(CONFIG.CHUNK_SIZE, CONFIG.CHUNK_SIZE, 32, 32);
            geo.rotateX(-Math.PI/2);
            
            const pos = geo.attributes.position;
            const colors = new Float32Array(pos.count * 3);
            const cSand = new THREE.Color(0xd2b48c), cGrass = new THREE.Color(0x447733);
            const cRock = new THREE.Color(0x666666), cSnow = new THREE.Color(0xffffff);

            for(let i=0; i<pos.count; i++) {
                const px = pos.getX(i) + cX*CONFIG.CHUNK_SIZE, pz = pos.getZ(i) + cZ*CONFIG.CHUNK_SIZE;
                const h = getHeight(px, pz);
                pos.setY(i, h);
                
                let col = cGrass;
                if(h < -1.5) col = cSand;
                else if(h > 6) col = cRock;
                if(h > 10) col = cSnow;
                col.toArray(colors, i*3);
            }
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geo.computeVertexNormals();

            const ground = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8 }));
            ground.receiveShadow = true;
            group.add(ground);

            if(Math.random() > 0.6) spawnEnemy(cX*CONFIG.CHUNK_SIZE + (Math.random()-0.5)*40, cZ*CONFIG.CHUNK_SIZE + (Math.random()-0.5)*40);

            group.position.set(cX*CONFIG.CHUNK_SIZE, 0, cZ*CONFIG.CHUNK_SIZE);
            scene.add(group);
            chunks.set(`${cX},${cZ}`, group);
        }

        function spawnEnemy(x, z) {
            const group = new THREE.Group();
            group.position.set(x, 15, z);
            group.userData = { hp: 100, maxHp: 100 };
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 1.5), new THREE.MeshStandardMaterial({color: 0x111111}));
            group.add(mesh);

            const hpBg = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.15), new THREE.MeshBasicMaterial({color: 0x000000}));
            hpBg.position.y = 2.5;
            const hpFill = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.15), new THREE.MeshBasicMaterial({color: 0x00ff00}));
            hpFill.position.set(0, 2.5, 0.01);
            group.userData.hpFill = hpFill;
            group.add(hpBg); group.add(hpFill);

            scene.add(group);
            enemies.push(group);
        }

        // --- PELAAJAN LATAUS ---
        loader.load('./chars/testchard.glb', (gltf) => {
            playerMesh = gltf.scene;
            playerMesh.rotation.y = Math.PI;
            playerMesh.position.y = -1.1;
            playerPivot.add(playerMesh);
            mixer = new THREE.AnimationMixer(playerMesh);
            gltf.animations.forEach(a => animations[a.name.toLowerCase()] = mixer.clipAction(a));
            animations['idle']?.play();
        });

        function updateUI() {
            document.getElementById('lvl-txt').innerText = PLAYER.level;
            document.getElementById('hp-bar').style.width = (PLAYER.hp/PLAYER.maxHp)*100 + "%";
            document.getElementById('xp-bar').style.width = (PLAYER.xp/PLAYER.nextLvl)*100 + "%";
            document.getElementById('stats').innerText = `DMG: ${PLAYER.baseDmg}-${PLAYER.baseDmg+40} | SPD: ${PLAYER.speed} | JMP: ${PLAYER.jump}`;
        }

        // --- TAISTELU JA LIIKE ---
        const keys = {}, vel = new THREE.Vector3();
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        window.addEventListener('mousedown', (e) => {
            if(controls.isLocked && !isAttacking && e.button === 0) {
                isAttacking = true;
                if(animations['kick']) {
                    animations['kick'].reset().setLoop(THREE.LoopOnce).play();
                    setTimeout(() => checkHit(), 300);
                    mixer.addEventListener('finished', () => isAttacking = false, {once: true});
                } else {
                    setTimeout(() => isAttacking = false, 500);
                    checkHit();
                }
            }
        });

        function checkHit() {
            enemies.forEach((en, i) => {
                if(en.position.distanceTo(playerPivot.position) < 4) {
                    const dmg = PLAYER.baseDmg + Math.floor(Math.random()*40);
                    en.userData.hp -= dmg;
                    en.userData.hpFill.scale.x = Math.max(0, en.userData.hp / en.userData.maxHp);
                    if(en.userData.hp <= 0) {
                        explode(en.position);
                        scene.remove(en);
                        enemies.splice(i, 1);
                        PLAYER.xp += 50;
                        if(PLAYER.xp >= PLAYER.nextLvl) {
                            PLAYER.level++; PLAYER.xp = 0; PLAYER.nextLvl += 50;
                            PLAYER.baseDmg += 10; PLAYER.speed += 0.5; PLAYER.jump += 1;
                        }
                        updateUI();
                    }
                }
            });
        }

        function explode(pos) {
            for(let i=0; i<12; i++) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,0.3), new THREE.MeshStandardMaterial({color: 0x222222}));
                p.position.copy(pos);
                p.userData.vel = new THREE.Vector3((Math.random()-0.5)*12, Math.random()*12, (Math.random()-0.5)*12);
                scene.add(p);
                particles.push(p);
            }
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);

            if(controls.isLocked) {
                // Kamera 3rd person logiikka
                const camDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const camSide = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                camDir.y = 0; camSide.y = 0; camDir.normalize(); camSide.normalize();

                if(!isAttacking) {
                    const move = new THREE.Vector3();
                    if(keys['KeyW']) move.add(camDir); if(keys['KeyS']) move.sub(camDir);
                    if(keys['KeyD']) move.add(camSide); if(keys['KeyA']) move.sub(camSide);

                    if(move.length() > 0) {
                        move.normalize();
                        vel.x = move.x * PLAYER.speed; vel.z = move.z * PLAYER.speed;
                        playerPivot.rotation.y = Math.atan2(move.x, move.z) + Math.PI;
                        animations['run']?.play();
                    } else {
                        vel.x *= 0.1; vel.z *= 0.1;
                        animations['run']?.stop();
                    }
                    if(keys['Space'] && isGrounded) {
                        vel.y = PLAYER.jump; isGrounded = false;
                        animations['jump']?.reset().setLoop(THREE.LoopOnce).play();
                    }
                }

                vel.y -= 50 * dt;
                playerPivot.position.addScaledVector(vel, dt);
                const groundH = getHeight(playerPivot.position.x, playerPivot.position.z);
                if(playerPivot.position.y < groundH) { playerPivot.position.y = groundH; vel.y = 0; isGrounded = true; }

                // --- KOLMANNEN PERSOONAN KAMERA ---
                const relativeCameraOffset = new THREE.Vector3(0, 5, 10); // Korkeus 5, etäisyys 10
                const cameraOffset = relativeCameraOffset.applyQuaternion(camera.quaternion);
                camera.position.copy(playerPivot.position).add(cameraOffset);
                
                // Estetään kameraa menemästä maan alle
                const camGround = getHeight(camera.position.x, camera.position.z);
                if(camera.position.y < camGround + 1) camera.position.y = camGround + 1;
            }

            // Maaston esilataus säteellä
            const pCX = Math.round(playerPivot.position.x / CONFIG.CHUNK_SIZE);
            const pCZ = Math.round(playerPivot.position.z / CONFIG.CHUNK_SIZE);
            for(let x = -CONFIG.DRAW_DISTANCE; x <= CONFIG.DRAW_DISTANCE; x++) {
                for(let z = -CONFIG.DRAW_DISTANCE; z <= CONFIG.DRAW_DISTANCE; z++) {
                    const key = `${pCX+x},${pCZ+z}`;
                    if(!chunks.has(key)) createChunk(pCX+x, pCZ+z);
                }
            }

            enemies.forEach(en => {
                const d = en.position.distanceTo(playerPivot.position);
                if(d < 20 && d > 1.8) {
                    en.position.addScaledVector(new THREE.Vector3().subVectors(playerPivot.position, en.position).normalize(), 5 * dt);
                    en.lookAt(playerPivot.position.x, en.position.y, playerPivot.position.z);
                }
                en.position.y = getHeight(en.position.x, en.position.z) + 1;
                en.userData.hpFill.lookAt(camera.position); // HP palkki osoittaa kameraan
            });

            particles.forEach((p, i) => {
                p.position.addScaledVector(p.userData.vel, dt);
                p.userData.vel.y -= 25 * dt;
                if(p.position.y < -10) { scene.remove(p); particles.splice(i,1); }
            });

            if(mixer) mixer.update(dt);
            renderer.render(scene, camera);
        }
        updateUI();
        animate();
    </script>
</body>
</html>
