<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>High-Fidelity Endless Flight</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Helvetica', sans-serif; }
        
        #loading { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            color: white; font-size: 24px; pointer-events: none; z-index: 999;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 8px;
        }

        #controls-help { 
            position: absolute; bottom: 20px; left: 20px; color: rgba(255,255,255,0.8); 
            pointer-events: none; font-size: 14px; text-shadow: 1px 1px 2px black;
        }

        #error-log {
            position: absolute; top: 0; left: 0; width: 100%; height: 50%; 
            background: rgba(50, 0, 0, 0.8); color: #ffcccc; padding: 20px; 
            display: none; z-index: 1000; overflow-y: scroll; font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="loading">Generating World...<br><span style="font-size:12px; opacity:0.7">If stuck, check console (F12)</span></div>
    <div id="error-log"></div>
    <div id="controls-help">
        WASD: Pitch/Roll | SHIFT: Throttle Up | CTRL: Throttle Down<br>
        +/-: Camera Distance | Plane flies physically.
    </div>

    <script>
        window.onerror = function(msg, url, line, col, error) {
            const log = document.getElementById('error-log');
            log.style.display = 'block';
            log.innerHTML += `<strong>Error:</strong> ${msg}<br><small>${url}:${line}</small><br><br>`;
            document.getElementById('loading').innerText = "ERROR DETECTED";
            return false;
        };
    </script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { createNoise2D } from 'simplex-noise';
        import GUI from 'lil-gui';

        // --- CONFIGURATION ---
        const CONFIG = {
            chunkSize: 1000,
            resolution: 128, 
            viewDistance: 2,
            waterLevel: -10,
            colors: {
                waterDeep: new THREE.Color(0x001e36),
                waterShallow: new THREE.Color(0x006994),
                foam: new THREE.Color(0xffffff),
                sand: new THREE.Color(0xe6c288),
                grass: new THREE.Color(0x2d5a27),
                stone: new THREE.Color(0x5a5a5a),
                snow: new THREE.Color(0xffffff),
            }
        };

        // --- INIT NOISE ---
        const noise2D = createNoise2D(); // Fixed: API changed in v4

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 8000);
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.0008);

        // --- SHADERS ---
        const waterVertexShader = `
            uniform float uTime;
            uniform float uWaveSize;
            uniform float uSpeed;
            varying float vElevation;
            varying vec2 vUv;
            varying vec3 vPosition;

            float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
            float noise(vec2 st) {
                vec2 i = floor(st); vec2 f = fract(st);
                float a = random(i); float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }

            void main() {
                vUv = uv;
                vec3 pos = position;
                float shift = uTime * uSpeed;
                float wave1 = sin(pos.x * 0.02 + shift) * cos(pos.z * 0.02 + shift) * uWaveSize;
                float wave2 = sin(pos.x * 0.05 - shift * 0.5) * uWaveSize * 0.5;
                float noiseWave = noise(pos.xz * 0.05 + shift) * uWaveSize * 0.5;
                pos.y += wave1 + wave2 + noiseWave;
                vElevation = pos.y;
                vPosition = pos;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const waterFragmentShader = `
            uniform vec3 uColorDeep;
            uniform vec3 uColorShallow;
            uniform vec3 uColorFoam;
            uniform float uFoamThreshold;
            varying float vElevation;
            varying vec3 vPosition;
            void main() {
                float mixStrength = smoothstep(-2.0, 3.0, vElevation);
                vec3 color = mix(uColorDeep, uColorShallow, mixStrength);
                float foamMix = step(uFoamThreshold, vElevation);
                color = mix(color, uColorFoam, foamMix * 0.8);
                gl_FragColor = vec4(color, 0.95);
                #include <tonemapping_fragment>
                #include <colorspace_fragment>
            }
        `;

        const waterMaterial = new THREE.ShaderMaterial({
            vertexShader: waterVertexShader,
            fragmentShader: waterFragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uWaveSize: { value: 3.5 },
                uSpeed: { value: 1.0 },
                uColorDeep: { value: CONFIG.colors.waterDeep },
                uColorShallow: { value: CONFIG.colors.waterShallow },
                uColorFoam: { value: CONFIG.colors.foam },
                uFoamThreshold: { value: 1.8 }
            },
            transparent: true,
            side: THREE.DoubleSide
        });

        // --- GROUND MATERIAL (Standard + Injection) ---
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            roughness: 0.9, metalness: 0.1, flatShading: false 
        });
        
        groundMaterial.onBeforeCompile = (shader) => {
            shader.uniforms.uColorSand = { value: CONFIG.colors.sand };
            shader.uniforms.uColorGrass = { value: CONFIG.colors.grass };
            shader.uniforms.uColorStone = { value: CONFIG.colors.stone };
            shader.uniforms.uColorSnow = { value: CONFIG.colors.snow };

            shader.vertexShader = shader.vertexShader.replace('#include <common>',
                `#include <common>\nvarying float vHeight;\nvarying float vSlope;`
            );
            shader.vertexShader = shader.vertexShader.replace('#include <fog_vertex>',
                `#include <fog_vertex>\nvHeight = position.y;\nvec3 up = vec3(0.0, 1.0, 0.0);\nvSlope = 1.0 - dot(normal, up);`
            );
            shader.fragmentShader = shader.fragmentShader.replace('#include <common>',
                `#include <common>\nuniform vec3 uColorSand;\nuniform vec3 uColorGrass;\nuniform vec3 uColorStone;\nuniform vec3 uColorSnow;\nvarying float vHeight;\nvarying float vSlope;`
            );
            shader.fragmentShader = shader.fragmentShader.replace('#include <map_fragment>',
                `
                vec3 gColor = uColorSand;
                float wGrass = smoothstep(-5.0, 5.0, vHeight);
                float wStone = smoothstep(30.0, 60.0, vHeight);
                float wSnow = smoothstep(110.0, 140.0, vHeight);
                float slopeMix = smoothstep(0.35, 0.6, vSlope);
                gColor = mix(gColor, uColorGrass, wGrass);
                gColor = mix(gColor, uColorStone, wStone);
                gColor = mix(gColor, uColorSnow, wSnow);
                gColor = mix(gColor, uColorStone, slopeMix);
                diffuseColor *= vec4(gColor, 1.0);
                `
            );
        };

        // --- GENERATION ---
        const NOISE_SETTINGS = {
            scale: 0.003, octaves: 6, persistence: 0.5, lacunarity: 2.0, exponent: 1.2, heightMultiplier: 180
        };

        function getTerrainHeight(x, z) {
            let amplitude = 1;
            let frequency = NOISE_SETTINGS.scale;
            let noiseHeight = 0;
            for (let i = 0; i < NOISE_SETTINGS.octaves; i++) {
                // Fixed: usage of createNoise2D
                let n = noise2D(x * frequency, z * frequency); 
                noiseHeight += n * amplitude;
                amplitude *= NOISE_SETTINGS.persistence;
                frequency *= NOISE_SETTINGS.lacunarity;
            }
            return Math.pow(Math.abs(noiseHeight), NOISE_SETTINGS.exponent) * Math.sign(noiseHeight) * NOISE_SETTINGS.heightMultiplier;
        }

        class ChunkManager {
            constructor() {
                this.chunks = {};
                this.loadedModels = { tree: null, rock: null };
                this.loadModels();
            }

            loadModels() {
                const loader = new GLTFLoader();
                const load = (path, type, col) => {
                    loader.load(path, (gltf) => {
                        gltf.scene.traverse(c => { if(c.isMesh) { c.castShadow=true; c.receiveShadow=true; }});
                        this.loadedModels[type] = gltf.scene;
                    }, undefined, (err) => {
                        console.warn(`Model ${path} not found, using cube.`);
                        const m = new THREE.Mesh(new THREE.BoxGeometry(2, type=='tree'?8:2, 2), new THREE.MeshStandardMaterial({color:col}));
                        m.castShadow=true; m.receiveShadow=true;
                        this.loadedModels[type] = m;
                    });
                };
                load('/mallit/tree.glb', 'tree', 0x2d5a27);
                load('/mallit/rock.glb', 'rock', 0x888888);
            }

            update(pos) {
                const cx = Math.floor(pos.x / CONFIG.chunkSize);
                const cz = Math.floor(pos.z / CONFIG.chunkSize);
                const keys = new Set();

                for (let x = -CONFIG.viewDistance; x <= CONFIG.viewDistance; x++) {
                    for (let z = -CONFIG.viewDistance; z <= CONFIG.viewDistance; z++) {
                        const key = `${cx+x},${cz+z}`;
                        keys.add(key);
                        if (!this.chunks[key]) this.createChunk(cx+x, cz+z);
                    }
                }
                for (const key in this.chunks) {
                    if (!keys.has(key)) {
                        scene.remove(this.chunks[key].mesh);
                        scene.remove(this.chunks[key].water);
                        scene.remove(this.chunks[key].objects);
                        this.chunks[key].geometry.dispose();
                        delete this.chunks[key];
                    }
                }
            }

            createChunk(cx, cz) {
                const size = CONFIG.chunkSize;
                const segs = CONFIG.resolution;
                const geo = new THREE.PlaneGeometry(size, size, segs, segs);
                geo.rotateX(-Math.PI/2);
                
                const pos = geo.attributes.position.array;
                for(let i=0; i<pos.length; i+=3) {
                    pos[i+1] = getTerrainHeight(pos[i]+cx*size, pos[i+2]+cz*size);
                }
                geo.computeVertexNormals();

                const mesh = new THREE.Mesh(geo, groundMaterial);
                mesh.position.set(cx*size, 0, cz*size);
                mesh.castShadow = true; mesh.receiveShadow = true;
                scene.add(mesh);

                const water = new THREE.Mesh(new THREE.PlaneGeometry(size,size,segs/4,segs/4).rotateX(-Math.PI/2), waterMaterial);
                water.position.set(cx*size, CONFIG.waterLevel, cz*size);
                scene.add(water);

                const objGroup = new THREE.Group();
                objGroup.position.set(cx*size, 0, cz*size);
                this.placeObjects(objGroup, cx, cz);
                scene.add(objGroup);

                this.chunks[`${cx},${cz}`] = { mesh, water, geometry: geo, objects: objGroup };
            }

            placeObjects(group, cx, cz) {
                if(!this.loadedModels.tree || !this.loadedModels.rock) return;
                for(let i=0; i<10; i++) {
                    const lx = (Math.random()-0.5)*CONFIG.chunkSize;
                    const lz = (Math.random()-0.5)*CONFIG.chunkSize;
                    const h = getTerrainHeight(lx+cx*CONFIG.chunkSize, lz+cz*CONFIG.chunkSize);
                    
                    let m = null, s = 1;
                    if(h>0 && h<50 && Math.random()>0.3) { m = this.loadedModels.tree.clone(); s = 3+Math.random()*3; }
                    else if(h>-10 && Math.random()>0.5) { m = this.loadedModels.rock.clone(); s = 2+Math.random()*5; }
                    
                    if(m && h>CONFIG.waterLevel) {
                        m.position.set(lx, h, lz);
                        m.scale.set(s,s,s);
                        m.rotation.y = Math.random()*6.28;
                        group.add(m);
                    }
                }
            }
        }

        // --- PLANE ---
        class Plane {
            constructor() {
                const geo = new THREE.ConeGeometry(1, 4, 32);
                geo.rotateX(Math.PI/2);
                this.mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color:0xff0000}));
                this.mesh.castShadow = true;
                scene.add(this.mesh);
                this.pos = new THREE.Vector3(0, 150, 0);
                this.vel = new THREE.Vector3(0,0,50);
                this.quat = new THREE.Quaternion();
                this.speed = 50; this.throttle = 0.5;
                this.input = {w:0,a:0,s:0,d:0,sh:0,ct:0};
                this.camDist = 30;
            }
            update(dt) {
                if(this.input.sh) this.throttle = Math.min(this.throttle+dt*0.5, 1);
                if(this.input.ct) this.throttle = Math.max(this.throttle-dt*0.5, 0);
                
                this.speed += ((30 + this.throttle*120) - this.speed) * dt * 0.5;
                
                const lx = new THREE.Vector3(1,0,0).applyQuaternion(this.quat);
                const ly = new THREE.Vector3(0,1,0).applyQuaternion(this.quat);
                const lz = new THREE.Vector3(0,0,1).applyQuaternion(this.quat);
                
                if(this.input.w) this.quat.multiply(new THREE.Quaternion().setFromAxisAngle(lx, dt));
                if(this.input.s) this.quat.multiply(new THREE.Quaternion().setFromAxisAngle(lx, -dt));
                if(this.input.a) { this.quat.multiply(new THREE.Quaternion().setFromAxisAngle(lz, dt*1.5)); this.quat.multiply(new THREE.Quaternion().setFromAxisAngle(ly, dt*0.5)); }
                if(this.input.d) { this.quat.multiply(new THREE.Quaternion().setFromAxisAngle(lz, -dt*1.5)); this.quat.multiply(new THREE.Quaternion().setFromAxisAngle(ly, -dt*0.5)); }

                this.mesh.quaternion.copy(this.quat);
                const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(this.quat).normalize();
                this.pos.add(fwd.multiplyScalar(this.speed*dt));
                
                const gh = getTerrainHeight(this.pos.x, this.pos.z);
                if(this.pos.y < gh+2) this.pos.y = gh+2;
                
                this.mesh.position.copy(this.pos);

                // Camera
                const off = new THREE.Vector3(0, 10, this.camDist).applyQuaternion(this.quat);
                camera.position.lerp(this.pos.clone().add(off), dt*5);
                camera.lookAt(this.pos.clone().add(fwd.multiplyScalar(20)));
            }
        }

        // --- SKY ---
        class Sky {
            constructor() {
                this.sun = new THREE.DirectionalLight(0xffffff, 2);
                this.sun.castShadow = true;
                this.sun.shadow.camera.far = 1000;
                this.sun.shadow.mapSize.set(2048,2048);
                scene.add(this.sun);
                scene.add(new THREE.HemisphereLight(0x87CEEB, 0x333333, 0.5));
                this.time = 0;
            }
            update(dt, pPos) {
                this.time += dt * 0.5;
                const angle = (this.time % 60) / 60 * Math.PI * 2;
                this.sun.position.set(pPos.x + Math.sin(angle)*500, Math.sin(angle+1.57)*500, pPos.z + Math.cos(angle)*500);
                this.sun.target.position.copy(pPos);
                this.sun.target.updateMatrixWorld();
                
                const h = Math.sin(angle+1.57);
                const col = h > 0 ? new THREE.Color(0x87CEEB) : new THREE.Color(0x000011);
                scene.background = col;
                scene.fog.color.lerp(col, dt);
            }
        }

        // --- MAIN LOOP ---
        const chunkManager = new ChunkManager();
        const plane = new Plane();
        const sky = new Sky();
        const clock = new THREE.Clock();

        window.addEventListener('keydown', e => {
            if(e.key=='w') plane.input.w=1; if(e.key=='s') plane.input.s=1;
            if(e.key=='a') plane.input.a=1; if(e.key=='d') plane.input.d=1;
            if(e.key=='Shift') plane.input.sh=1; if(e.key=='Control') plane.input.ct=1;
            if(e.key=='+') plane.camDist-=2; if(e.key=='-') plane.camDist+=2;
        });
        window.addEventListener('keyup', e => {
            if(e.key=='w') plane.input.w=0; if(e.key=='s') plane.input.s=0;
            if(e.key=='a') plane.input.a=0; if(e.key=='d') plane.input.d=0;
            if(e.key=='Shift') plane.input.sh=0; if(e.key=='Control') plane.input.ct=0;
        });

        const gui = new GUI({ title: 'Settings' });
        gui.add(waterMaterial.uniforms.uWaveSize, 'value', 0, 10).name('Wave Size');
        gui.addColor(CONFIG.colors, 'sand').name('Sand Color').onChange(() => chunkManager.chunks={});

        let loaded = false;
        function animate() {
            requestAnimationFrame(animate);
            if(!loaded) { document.getElementById('loading').style.display='none'; loaded=true; }
            
            const dt = clock.getDelta();
            plane.update(dt);
            sky.update(dt, plane.pos);
            chunkManager.update(plane.pos);
            waterMaterial.uniforms.uTime.value += dt;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
